# Chains

## Define chains

Chains are defined in the `/chains` directory.
The convection is `chains/<name>/main.py`.

Example:

```
chains/
  question-answering/
    latest.py
  agent-based-chat.py/
    latest.py
```

## Chain dependencies

Often chains have dependencies on [vector stores](../docs/database.md#vector-stores).
You must define the dependencies via `@dependency` directives.

Example:

```python
@dependency("vector_store", "index_documents_0_0_1")
def retrive_from_vector_store
  # Your business logic
end
```

## Chain versioning

To deploy a chain to production, it must be versioned,
so that you can ensure backward-compabiility, reproducibility, and traceability.

To compile a chain, you can execute `langapp compile` CLI command.
This automatically generates the following files:

Example:

```
chains/
  question-answering/
    latest.py           # Modifiable, the latest version. This should NOT be used in production.
    0_0_1.py            # Immutable, it's complied from the latest version. This can be used in production.
    0_0_2.py            # Immutable, it's complied from the latest version. This can be used in production.
```

Example of a versioned file:

```
# 0_0_1.py

"""
This file is auto-generated by LangApp. DO NOT EDIT.
"""

....
```

Chain versioning follows [Semantic Versioning](../docs/glossary.md#semantic-versioning).

NOTE: This is a shallow versioning that it doesn't compile dependent packages or shared components that are cross-referenced by multiple versions. Hence you should be careful when you upgrade your dependencies.

## Test chains locally

To test a chain, you can execute `langapp execute chain --version <version>`.
